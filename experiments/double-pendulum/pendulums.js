const jsNoteContainerId = "js-note-container";
const mainCanvasId = "main-canvas";
const pendulumCanvasId = "pendulum-canvas";
const energyValId = "energy-val";

/*

getDerivatives takes the input state:
[theta1, omega1, theta2, omega2]

Where:
1. theta1 and theta2 are the angles of the rods relative to the vertical.
2. omega1 and omega2 are the rates of change of those angles (dtheta1 and
dtheta2, respectively.).

It calculates the derivative of each, returning:
[dtheta1, domega1, dtheta2, domega2]

Since dtheta1 and dtheta2 are trivial (as they are an input to the function),
all of the complexity comes from working out the rate of change of the angle
deltas.

Unfortunately, my classical mechanics is very poor and this function comment is
not the place to learn about it. The function body is generated by ChatGPT (and
therefore probably a rinsed and recycled stackoverflow comment somewhere: if you
think this is lifted from somewhere specific that is due credit, please email me
at craig at <this domain> so I can assign credit).

While researching, these showed up as promising things to read. But I haven't
got around to fully understanding this. Also, if you know of a really good
learning resource for chaos in classical mechanics, let me know!

1. https://www.reddit.com/r/Physics/comments/s5ppia/double_pendulum_written_in_python_and_visualized/
2. https://en.wikipedia.org/wiki/Symplectic_integrator
*/
function getDerivatives(state, params = { m1: 1, m2: 1, L1: 1, L2: 1, g: 9.81 }) {
    const { m1, m2, L1, L2, g } = params;
    const [theta1, omega1, theta2, omega2] = state;

    const delta = theta2 - theta1;
    const sinDelta = Math.sin(delta);
    const cosDelta = Math.cos(delta);

    const denom1 = (m1 + m2) * L1 - m2 * L1 * cosDelta * cosDelta;
    const denom2 = (L2 / L1) * denom1;

    const domega1 = (
        m2 * L1 * omega1 * omega1 * sinDelta * cosDelta +
        m2 * g * Math.sin(theta2) * cosDelta +
        m2 * L2 * omega2 * omega2 * sinDelta -
        (m1 + m2) * g * Math.sin(theta1)
    ) / denom1;

    const domega2 = (
        -m2 * L2 * omega2 * omega2 * sinDelta * cosDelta +
        (m1 + m2) * g * Math.sin(theta1) * cosDelta -
        (m1 + m2) * L1 * omega1 * omega1 * sinDelta -
        (m1 + m2) * g * Math.sin(theta2)
    ) / denom2;

    const dtheta1 = omega1;
    const dtheta2 = omega2;

    return [dtheta1, domega1, dtheta2, domega2];
}

/*

eulerStep calculates the next step using the Euler method. This is simple: just
calculate the next value given a timestep and the derivative.

https://en.wikipedia.org/wiki/Euler_method
*/
function eulerStep(state, dt) {
    const derivatives = getDerivatives(state);
    return state.map((v, i) => v + dt * derivatives[i]);
}

/*

RK4 is another approximation of the integral, called Runge-Kutta. It is
generally a better approximation.

https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
*/
function rk4Step(state, dt) {
    const k1 = getDerivatives(state);
    const k2 = getDerivatives(state.map((v, i) => v + 0.5 * dt * k1[i]));
    const k3 = getDerivatives(state.map((v, i) => v + 0.5 * dt * k2[i]));
    const k4 = getDerivatives(state.map((v, i) => v + dt * k3[i]));

    return state.map((v, i) =>
        v + (dt / 6) * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i])
    );
}

var mainCanvas;
var mainCtx;
var pendulumCanvas;
var pendulumCtx;
var energyValContainer;

const theta1 = Math.PI / 1.1;
const theta2 = 0;
const dtheta1 = 0;
const dtheta2 = 0;
const dtPerFrame = 1 / 120; // TODO: Don't assume FPS, this will move slowly on slow systems
const dtPerStep = 1 / 20;
const L1 = 50;
const L2 = 50;
const m1 = 1;
const m2 = 1;
const g = 9.81;
var state = [theta1, dtheta1, theta2, dtheta2];

/*

Calculating the total energy is useful for analyzing the integral approximation.

*/
function calculateEnergy(state) {
    const [theta1, omega1, theta2, omega2] = state;

    const y1 = L1 * Math.cos(theta1);
    const y2 = y1 + L2 * Math.cos(theta2);

    const vx1 = L1 * omega1 * Math.cos(theta1);
    const vy1 = L1 * omega1 * Math.sin(theta1);

    const vx2 = vx1 + L2 * omega2 * Math.cos(theta2);
    const vy2 = vy1 + L2 * omega2 * Math.sin(theta2);

    const T = 0.5 * m1 * (vx1 ** 2 + vy1 ** 2) + 0.5 * m2 * (vx2 ** 2 + vy2 ** 2);
    const V = m1 * g * y1 + m2 * g * y2;
    return T + V;
}

function nsteps(state, n, stepFunction = rk4Step) {
    let result = state;
    for (let i = 0; i < n; i++) {
        result = stepFunction(result, dtPerStep);
    }
    return result;
}

/*

Perform a number of steps on two states, and compute their divergence.
The divergence is computed as the euclidian distance between the two states
angular velocities.

*/
function calculateDivergenceDelta(state1, state2, steps) {
    const state1n = nsteps(state1, steps);
    const state2n = nsteps(state2, steps);

    const dtheta1 = state1n[0] - state2n[0];
    const domega1 = state1n[1] - state2n[1];
    const dtheta2 = state1n[2] - state2n[2];
    const domega2 = state1n[3] - state2n[3];

    return Math.sqrt(dtheta1**2 + domega1**2 + dtheta2**2 + domega2**2);
}

/*

As an alternative, we can compute the number of iterations it takes before the
pendulums diverge. We can even use a simpler divergence calculation like the
difference of the sum of the angles.

I originally tried to calculate divergence using all state parameters because
the position may technically be the same but the velocity could be different (as
an extreme example, moving in the opposite direction), but to get to that point
the rods would have to have diverged far more than necessary for detection
anyway.

This lacks the details, visually, of the divergence delta calculation. It is
also not as performant as I'd hoped, relatively. I'd hoped that the possible
early termination for chaotic regions would save a lot of time, but it doesn't
seem to make a huge difference, and you lose the nice continuous variation in
more stable regions.

*/
function iterationsUntilDivergence(state1, state2, maxIterations = 200, threshold = 0.1, stepFunction = rk4Step) {
    let result1 = state1;
    let result2 = state2;
    for (let i = 0; i < maxIterations; i++) {
        result1 = stepFunction(result1, dtPerStep);
        result2 = stepFunction(result2, dtPerStep);
        const firstTotal = result1[0] + result1[2];
        const secondTotal = result2[0] + result2[2];
        if (secondTotal - firstTotal > threshold) {
            return i;
        }
    }
    return maxIterations;
}


function drawPendulum(canvas, ctx, state) {
    const [theta1, , theta2,] = state;
    const originX = canvas.width / 2;
    const originY = canvas.height / 2;

    const x1 = originX + L1 * Math.sin(theta1);
    const y1 = originY + L1 * Math.cos(theta1);

    const x2 = x1 + L2 * Math.sin(theta2);
    const y2 = y1 + L2 * Math.cos(theta2);

    ctx.fillStyle = "#FFA500";
    ctx.strokeStyle = "#FFA500";

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    ctx.moveTo(originX, originY);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(x1, y1, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(x2, y2, 2, 0, Math.PI * 2);
    ctx.fill();
}

const leftRads = -1.4*Math.PI;
const rightRads = 1.4*Math.PI;
const topRads = 1.4*Math.PI;
const bottomRads = -1.4*Math.PI;
const maxIterations = 200;
const radsDelta = 0.005;

function drawPendulumFractal(canvas, ctx) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
            const xRads = leftRads + (x / canvas.width) * (rightRads - leftRads);
            const yRads = topRads + (y / canvas.height) * (bottomRads - topRads);
            const mainState = [xRads, 0, yRads, 0];
            const deltaState = [xRads + radsDelta, 0, yRads + radsDelta, 0];
            const divergenceDelta = calculateDivergenceDelta(mainState, deltaState, 100);

            const scaled = Math.log10(divergenceDelta + 1e-10);
            const hue = 120 - Math.min(120, scaled * 120);
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(x, y, 1, 1);
        }
    }
}

function runFrame() {
    drawPendulum(pendulumCanvas, pendulumCtx, state);
    energyValContainer.innerHTML = calculateEnergy(state);

    state = rk4Step(state, dtPerFrame);

    window.requestAnimationFrame(runFrame);
}

function runMainLoop() {
    window.requestAnimationFrame(runFrame);
}

function main() {
    energyValContainer = document.getElementById(energyValId);
    const jsNote = document.getElementById(jsNoteContainerId);
    jsNote.remove();

    mainCanvas = document.getElementById(mainCanvasId);
    mainCtx = mainCanvas.getContext("2d");
    pendulumCanvas = document.getElementById(pendulumCanvasId);
    pendulumCtx = pendulumCanvas.getContext("2d");

    drawPendulumFractal(mainCanvas, mainCtx);
    runMainLoop();
}

window.onload = main;


/*

TODO: Identify best constants for beauty
TODO: Add hover feature -- Show the pendulum for the hovered area
TODO: Periodicity view? Somehow show attractors
TODO: Progressive loading of results
TODO: Don't use the main thread: do this stuff in a worker

*/