const jsNoteContainerId = "js-note-container";
const mainCanvasId = "main-canvas";

/*

getDerivatives takes the input state:
[theta1, omega1, theta2, omega2]

Where:
1. theta1 and theta2 are the angles of the rods relative to the vertical.
2. omega1 and omega2 are the rates of change of those angles (dtheta1 and
dtheta2, respectively.).

It calculates the derivative of each, returning:
[dtheta1, domega1, dtheta2, domega2]

Since dtheta1 and dtheta2 are trivial (as they are an input to the function),
all of the complexity comes from working out the rate of change of the angle
deltas.

Unfortunately, my classical mechanics is very poor and this function comment is
not the place to learn about it. The function body is generated by ChatGPT (and
therefore probably a rinsed and recycled stackoverflow comment somewhere: if you
think this is lifted from somewhere specific that is due credit, please email me
at craig at <this domain> so I can assign credit).

While researching, these showed up as promising things to read. But I haven't
got around to fully understanding this. Also, if you know of a really good
learning resource for chaos in classical mechanics, let me know!

1. https://www.reddit.com/r/Physics/comments/s5ppia/double_pendulum_written_in_python_and_visualized/
2. https://en.wikipedia.org/wiki/Symplectic_integrator
*/
function getDerivatives(state, params = { m1: 1, m2: 1, L1: 1, L2: 1, g: 9.81 }) {
    const { m1, m2, L1, L2, g } = params;
    const [theta1, omega1, theta2, omega2] = state;

    const delta = theta2 - theta1;
    const sinDelta = Math.sin(delta);
    const cosDelta = Math.cos(delta);

    const denom1 = (m1 + m2) * L1 - m2 * L1 * cosDelta * cosDelta;
    const denom2 = (L2 / L1) * denom1;

    const domega1 = (
        m2 * L1 * omega1 * omega1 * sinDelta * cosDelta +
        m2 * g * Math.sin(theta2) * cosDelta +
        m2 * L2 * omega2 * omega2 * sinDelta -
        (m1 + m2) * g * Math.sin(theta1)
    ) / denom1;

    const domega2 = (
        -m2 * L2 * omega2 * omega2 * sinDelta * cosDelta +
        (m1 + m2) * g * Math.sin(theta1) * cosDelta -
        (m1 + m2) * L1 * omega1 * omega1 * sinDelta -
        (m1 + m2) * g * Math.sin(theta2)
    ) / denom2;

    const dtheta1 = omega1;
    const dtheta2 = omega2;

    return [dtheta1, domega1, dtheta2, domega2];
}

/*

eulerStep calculates the next step using the Euler method. This is simple: just
calculate the next value given a timestep and the derivative.

https://en.wikipedia.org/wiki/Euler_method
*/
function eulerStep(state, dt) {
    const derivatives = getDerivatives(state);
    return state.map((v, i) => v + dt * derivatives[i]);
}

var canvas;
var ctx;
const theta1 = Math.PI / 2.0;
const theta2 = 0;
const dtheta1 = 0;
const dtheta2 = 0;
const dtPerFrame = 1 / 60; // TODO: Don't assume 60 FPS, this will move slowly on slow systems
var state = [theta1, dtheta1, theta2, dtheta2];

function draw(canvas, ctx, state) {
  const [theta1, , theta2, ] = state;
  const originX = canvas.width / 2;
  const originY = canvas.height / 2;
  const L1 = 50;
  const L2 = 50;

  const x1 = originX + L1 * Math.sin(theta1);
  const y1 = originY + L1 * Math.cos(theta1);

  const x2 = x1 + L2 * Math.sin(theta2);
  const y2 = y1 + L2 * Math.cos(theta2);

  ctx.fillStyle = "#FFA500";
  ctx.strokeStyle = "#FFA500";

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
  ctx.moveTo(originX, originY);
  ctx.lineTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(x1, y1, 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.beginPath();
  ctx.arc(x2, y2, 2, 0, Math.PI * 2);
  ctx.fill();
}


function runFrame() {
    draw(canvas, ctx, state);
    state = eulerStep(state, dtPerFrame);

    window.requestAnimationFrame(runFrame);
}

function runMainLoop() {
    const jsNote = document.getElementById(jsNoteContainerId);
    jsNote.remove();

    canvas = document.getElementById(mainCanvasId);
    ctx = canvas.getContext("2d");

    window.requestAnimationFrame(runFrame);
}

window.onload = runMainLoop;