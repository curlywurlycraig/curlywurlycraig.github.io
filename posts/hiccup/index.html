<html>
  <head>
    <title>Hiccup: Representing the DOM with arrays</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="./index.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Raleway&display=swap" rel="stylesheet"> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <header>
      <a href="/">
        <img src="/favicon.ico"/>
      </a>
    </header>

    <h1>Hiccup: Representing the DOM with arrays</h1>

<p>
  Complaints and conversations about DOM interactivity (particularly about
  frameworks) are very much in vogue. I'd like to avoid too much
  pontification about my experience with JS frameworks, likes and dislikes, the
  industry as a whole, pile-ons against React + hooks, etc., since this has been
  debated to death on sites like Hacker News (which I have regretably 
  participated in).
</p>

<p>
  Instead, I'd like to focus on a fun, quiet corner of JS DOM hackery that I
  enjoy working with and which has a nice history.
</p>

<h2>What is hiccup?</h2>

<p>
Hiccup is a very simple way to represent a DOM hierarchy. Well, it can represent
any hierarchy really, and in many ways is so simple that it is presumably used
in many contexts in many codebases without such a name.
</p>

<p>
The basic idea is to take a DOM hierarchy, such as:
</p>

<div class="code-container">
  <pre><code>&lt;<span class="parsed_TAG">div</span> id=<span class="parsed_STRING">"men"</span>&gt;
  &lt;<span class="parsed_TAG">p</span>&gt;hello world!&lt;/<span class="parsed_TAG">p</span>&gt;
&lt;<span class="parsed_TAG">div</span>&gt;</code></pre>
</div>

<p>
  And represent it as a nested array:
</p>

<div class="code-container">
<pre><code key="__reec0eec1c0">[<span class="parsed_STRING" key="__reec0eec1c0c1">"div"</span>, {id: <span class="parsed_STRING" key="__reec0eec1c0c3">"men"</span>}, [
  [<span class="parsed_STRING" key="__reec0eec1c0c5">"p"</span>, {}, [<span class="parsed_STRING" key="__reec0eec1c0c7">"hello world!"</span>]], <span class="parsed_COMMENT" key="__reec0eec1c0c9">// children of "men"</span>
]];
</code></pre>
</div>

<p>
  The idea and name come from James Reeve's
  <a href="https://github.com/weavejester/hiccup">Clojure project</a>,
  and it's easy to see how this representation could be valuable in Clojure
  with its Lispy style.
</p>

<p>
  This idea is built upon in JS, as I found in Bruno Fidelis' project <a
  href="https://github.com/btfidelis/hiccupjs">hiccupjs</a>, to which I made
  small contributions and have since mutated in various ways across a few recent
  small projects (including the <a href="/experiments/text-editor/">text editor
  project</a> which I published at the same time as the post you are reading).
</p>

<h2>Hiccup and the DOM</h2>

<p>
  Given a hiccup array, there are only a small number of things we need to be
  able to do to use it on the DOM from JS.
</p>

<p>
  The result is a set of simple utilities which, together, enable declarative
  changes to the DOM and the ability to patch those changes.
  Something beatiful about the result when trying to reduce these problems to
  their most minimal is that you eventually arrive at something almost
  archetypal, where the inherent simplicity in the tree structure of the DOM
  shines through.
</p>

<h3>Patching element attributes</h3>

<p>
    The first of these is patching element attributes. That is, given a DOM
    element and an object (a mapping of attribute name to value), update the DOM
    element's attributes.
</p>

<div class="code-container">
  <pre><code key="__reec0eec1c0"><span class="parsed_COMMENT" key="__reec0eec1c0c0">/**
 * Applies a dictionary representation of the HTMLElement properties
 * to the element.
 */</span>
<span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c2">const</span> updateAttrs = (el: TaggedElement, attrs: <span class="parsed_KEYWORD" key="__reec0eec1c0c4">object</span>) =&gt; {
  <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c6">const</span> [, prevAttrs] = el._hic || [];

  Object
    .<span class="parsed_FUNC_CALL" key="__reec0eec1c0c8">entries</span>(attrs)
    .<span class="parsed_FUNC_CALL" key="__reec0eec1c0c10">forEach</span>(([k, v]) =&gt; { 
      <span class="parsed_KEYWORD" key="__reec0eec1c0c12">if</span> (prevAttrs &amp;&amp; <span class="parsed_KEYWORD" key="__reec0eec1c0c14">typeof</span> prevAttrs[k] === <span class="parsed_STRING" key="__reec0eec1c0c16">"function"</span>) {
        el.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c18">removeEventListener</span>(k, prevAttrs[k]);
      }

      <span class="parsed_KEYWORD" key="__reec0eec1c0c20">if</span> (<span class="parsed_KEYWORD" key="__reec0eec1c0c22">typeof</span> v === FUNC_TOKEN) {
        el.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c24">addEventListener</span>(k.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c26">toLowerCase</span>(), v);
      } <span class="parsed_KEYWORD" key="__reec0eec1c0c28">else</span> {
        <span class="parsed_COMMENT" key="__reec0eec1c0c30">// Weird specific case. The view doesn't update if you do el.setAttribute('value', 10) on an input element.</span>
        <span class="parsed_KEYWORD" key="__reec0eec1c0c32">if</span> (k === <span class="parsed_STRING" key="__reec0eec1c0c34">'value'</span> || k === <span class="parsed_STRING" key="__reec0eec1c0c36">'disabled'</span>) {
          el[k] = v;
          <span class="parsed_KEYWORD" key="__reec0eec1c0c38">return</span>;
        }
        
        <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c40">const</span> asElement = el <span class="parsed_KEYWORD" key="__reec0eec1c0c42">as</span> TaggedElement;
        <span class="parsed_KEYWORD" key="__reec0eec1c0c44">if</span> (asElement.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c46">getAttribute</span>(k) !== v) {
          asElement.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c48">setAttribute</span>(k, v);
        }
      }
    })

  <span class="parsed_KEYWORD" key="__reec0eec1c0c50">return</span> el;
}
   </code></pre>
</div>


<h3>Recursive rendering of function elements</h3>

<p>
  With one small addition, we can add some idea of a custom component too: allow
  functions as the first entry in a hiccup array. For example:
</p>

<div class="code-container">
  <pre class="editor_draw" key="__reec0eec1"><code key="__reec0eec1c0"><span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c0">const</span> StyledParagraph = ({ children }) =&gt;
    [<span class="parsed_STRING" key="__reec0eec1c0c2">"p"</span>, { <span class="parsed_KEYWORD" key="__reec0eec1c0c4">class</span>: <span class="parsed_STRING" key="__reec0eec1c0c6">"my_class"</span> }, children];

<span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c8">const</span> myStyledElement = [StyledParagraph, {}, <span class="parsed_STRING" key="__reec0eec1c0c10">"hello"</span>];</code></pre>
</div>

<p>
  We can write a simple function to expand <code class="inline">myStyledElement</code> into
  nested hiccup that only contains "real" DOM elements:
</p>

<div class="code-container">
<pre><code><span class="parsed_COMMENT">/**
  Given some hiccup, resolve any components to their resulting DOM only
  hiccup. That is, only hiccup elements with lower case tag names should remain.
  
  This entails running the components with their attributes.

  Code to maintain unique keys has been removed from the below for simplicity,
  as well as Typescript types.
*/</span>
<span class="parsed_KEYWORD">export</span> <span class="parsed_KEYWORD_CONST">const</span> render = (hic) =&gt; {
 <span class="parsed_KEYWORD">if</span> (!<span class="parsed_FUNC_CALL">isHic</span>(hic)) {
   <span class="parsed_KEYWORD">return</span> hic;
 }

 <span class="parsed_KEYWORD_CONST">const</span> [tag, attrs, children] = hic;
 <span class="parsed_KEYWORD_CONST">const</span> renderedChildren = children
   .<span class="parsed_FUNC_CALL">map</span>((child: HicType) =&gt; {
     <span class="parsed_KEYWORD">return</span> <span class="parsed_FUNC_CALL">render</span>(child);
   });

 <span class="parsed_KEYWORD">if</span> (<span class="parsed_KEYWORD">typeof</span> tag === FUNC_TOKEN) {
   <span class="parsed_KEYWORD_CONST">const</span> renderResult = <span class="parsed_FUNC_CALL">tag</span>({ ...attrs, children: renderedChildren });
   <span class="parsed_KEYWORD">return</span> <span class="parsed_FUNC_CALL">render</span>(renderResult);
 }

 <span class="parsed_KEYWORD" >return</span> [tag, attrs, renderedChildren];
};
</code></pre>
</div>

<h3>Applying hiccup to the DOM</h3>

<div class="code-container">
  <pre class="editor_draw" key="__reec0eec1"><code key="__reec0eec1c0"><span class="parsed_COMMENT" key="__reec0eec1c0c0">/**
   Given an element and an array of children, make the array of elements
   be the children of the element, while being minimally destructive of
   existing children. This is so that state associated with element instances
   is not damaged (for example, the element does not lose focus).
 */</span>
<span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c2">const</span> updateChildren = (el, newChildren) =&gt; {
  for (<span class="parsed_KEYWORD" key="__reec0eec1c0c4">let</span> i = newChildren.length - <span class="parsed_NUMBER" key="__reec0eec1c0c6">1</span>; i &gt;= <span class="parsed_NUMBER" key="__reec0eec1c0c8">0</span>; i--) {
    <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c10">const</span> currChild = newChildren[i];
    <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c12">const</span> desiredNextSibling = newChildren[i+<span class="parsed_NUMBER" key="__reec0eec1c0c14">1</span>] || <span class="parsed_KEYWORD" key="__reec0eec1c0c16">null</span>;
    <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c18">const</span> existingNextSibling = currChild.nextSibling;
    <span class="parsed_KEYWORD" key="__reec0eec1c0c20">if</span> (desiredNextSibling !== existingNextSibling || !el.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c22">contains</span>(currChild)) {
      el?.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c24">insertBefore</span>(currChild, desiredNextSibling);
    }
  }

  <span class="parsed_KEYWORD" key="__reec0eec1c0c26">while</span> (el.childNodes.length &gt; newChildren.length) {
    el?.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c28">removeChild</span>(el.childNodes[<span class="parsed_NUMBER" key="__reec0eec1c0c30">0</span>]);
  }

  <span class="parsed_KEYWORD" key="__reec0eec1c0c32">return</span> el;
}

<span class="parsed_COMMENT" key="__reec0eec1c0c34">/**
   Given some HTML element, update that element and its children with the hiccup.
   This preserves existing HTML elements without removing and creating new ones.
*/</span>
<span class="parsed_KEYWORD" key="__reec0eec1c0c36">export</span> <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c38">const</span> apply = (hic, el) =&gt; {
  <span class="parsed_KEYWORD" key="__reec0eec1c0c40">let</span> result = el;

  <span class="parsed_KEYWORD" key="__reec0eec1c0c42">if</span> (!hic &amp;&amp; hic !== <span class="parsed_STRING" key="__reec0eec1c0c44">""</span>) {
    <span class="parsed_KEYWORD" key="__reec0eec1c0c46">return</span> <span class="parsed_KEYWORD" key="__reec0eec1c0c48">null</span>;
  }
  
  <span class="parsed_COMMENT" key="__reec0eec1c0c50">// Basically leaf text nodes. Early return because they cannot have children</span>
  <span class="parsed_KEYWORD" key="__reec0eec1c0c52">if</span> (!<span class="parsed_FUNC_CALL" key="__reec0eec1c0c54">isHic</span>(hic)) {
    <span class="parsed_KEYWORD" key="__reec0eec1c0c56">if</span> (el?.nodeType !== <span class="parsed_NUMBER" key="__reec0eec1c0c58">3</span>) {
      <span class="parsed_KEYWORD" key="__reec0eec1c0c60">return</span> document.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c62">createTextNode</span>(hic);
    }

    <span class="parsed_KEYWORD" key="__reec0eec1c0c64">if</span> (el.textContent !== hic) {
      el.textContent = hic;
    }

    <span class="parsed_KEYWORD" key="__reec0eec1c0c66">return</span> el;
  }

  <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c68">const</span> [prevTag, prevAttrs] = el?._hic || [];
  <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c70">const</span> [tag, attrs] = hic;

  <span class="parsed_COMMENT" key="__reec0eec1c0c72">// New element case. When creating elements we need to specify the correct namespace</span>
  <span class="parsed_KEYWORD" key="__reec0eec1c0c74">if</span> (prevTag !== tag || !result) {
    <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c76">const</span> currentNS = attrs.xmlns || (tag === <span class="parsed_STRING" key="__reec0eec1c0c78">'svg'</span> ? <span class="parsed_STRING" key="__reec0eec1c0c80">'http://www.w3.org/2000/svg'</span> : <span class="parsed_STRING" key="__reec0eec1c0c82">'http://www.w3.org/1999/xhtml'</span>);
    result = document.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c84">createElementNS</span>(currentNS, tag);
  }

  <span class="parsed_COMMENT" key="__reec0eec1c0c86">// Update element with attrs (we defined this earlier)</span>
  <span class="parsed_FUNC_CALL" key="__reec0eec1c0c88">updateAttrs</span>(result, attrs);

  <span class="parsed_COMMENT" key="__reec0eec1c0c90">// Store the hic used as a "hidden" property of the DOM element.</span>
  result._hic = hic;

  <span class="parsed_COMMENT" key="__reec0eec1c0c92">// Apply each child and assign as a child to this element.</span>
  <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c94">const</span> children = <span class="parsed_FUNC_CALL" key="__reec0eec1c0c96">isHic</span>(hic) ? hic[<span class="parsed_NUMBER" key="__reec0eec1c0c98">2</span>] : [];
  <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c100">const</span> newChildren = children
    .<span class="parsed_FUNC_CALL" key="__reec0eec1c0c102">filter</span>(c =&gt; c)
    .<span class="parsed_FUNC_CALL" key="__reec0eec1c0c104">map</span>((child, idx) =&gt; {
      <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c106">const</span> existingNode = el?.childNodes[idx];
      <span class="parsed_KEYWORD" key="__reec0eec1c0c108">return</span> <span class="parsed_FUNC_CALL" key="__reec0eec1c0c110">apply</span>(child, existingNode <span class="parsed_KEYWORD" key="__reec0eec1c0c112">as</span> TaggedElement);
    });

  <span class="parsed_FUNC_CALL" key="__reec0eec1c0c114">updateChildren</span>(result, newChildren);

  <span class="parsed_KEYWORD" key="__reec0eec1c0c116">if</span> (el !== result) {
    el?.parentNode?.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c118">replaceChild</span>(result, el!!);
  }

  <span class="parsed_KEYWORD" key="__reec0eec1c0c120">return</span> result;
}</code></pre>
</div>
  </body>
</html>