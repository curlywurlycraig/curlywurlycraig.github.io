<html>
  <head>
    <title>Hiccup: Representing the DOM with arrays</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="./index.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Raleway&display=swap" rel="stylesheet"> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>

  <body>
    <header>
      <a href="/">
        <img src="/favicon.ico"/>
      </a>
    </header>

    <h1>Hiccup: Representing the DOM with arrays</h1>

<p>
  Complaints and conversations about DOM interactivity (particularly about
  frameworks) are very much in vogue. I'd like to avoid too much
  pontification about my experience with JS frameworks, likes and dislikes, the
  industry as a whole, pile-ons against React + hooks, etc., since this has been
  debated to death on sites like Hacker News (which I have regretably 
  participated in).
</p>

<p>
  Instead, I'd like to focus on a fun, quiet corner of JS DOM hackery that I
  enjoy working with and which has a nice history.
</p>

<p>
  Something beatiful about the result when trying to reduce these problems to
  their most minimal is that you eventually arrive at something almost
  archetypal, where the inherent simplicity in the tree structure of the DOM
  shines through.
</p>

<h2>What is hiccup?</h2>

<p>
Hiccup is a very simple way to represent a DOM hierarchy. Well, it can represent
any hierarchy really, and in many ways is so simple that it is presumably used
in many contexts in many codebases without such a name.
</p>

<p>
The basic idea is to take a DOM hierarchy, such as:
</p>

<div class="code-container">
  <pre><code>&lt;<span class="parsed_TAG">div</span> id=<span class="parsed_STRING">"men"</span>&gt;
  &lt;<span class="parsed_TAG">p</span>&gt;hello world!&lt;/<span class="parsed_TAG">p</span>&gt;
&lt;<span class="parsed_TAG">div</span>&gt;</code></pre>
</div>

<p>
  And represent it as a nested array:
</p>

<div class="code-container">
<pre><code key="__reec0eec1c0">[<span class="parsed_STRING" key="__reec0eec1c0c1">"div"</span>, {id: <span class="parsed_STRING" key="__reec0eec1c0c3">"men"</span>}, [
  [<span class="parsed_STRING" key="__reec0eec1c0c5">"p"</span>, {}, [<span class="parsed_STRING" key="__reec0eec1c0c7">"hello world!"</span>]], <span class="parsed_COMMENT" key="__reec0eec1c0c9">// children of "men"</span>
]];
</code></pre>
</div>

<p>
  The idea and name come from James Reeve's
  <a href="https://github.com/weavejester/hiccup">Clojure project</a>,
  and it's easy to see how this representation could be valuable in Clojure
  with its Lispy style.
</p>

<p>
  This idea is built upon in JS, as I found in Bruno Fidelis' project <a
  href="https://github.com/btfidelis/hiccupjs">hiccupjs</a>, to which I made
  small contributions and have since mutated in various ways across a few recent
  small projects (including the <a href="/experiments/text-editor/">text editor
  project</a> which I published at the same time as the post you are reading).
</p>

<h2>Hiccup and the DOM</h2>

<p>
  Given a hiccup array, there are only a small number of things we need to be
  able to do to use it on the DOM from JS.
</p>

<h3>Patching element attributes</h3>

<p>
    The first of these is patching element attributes. That is, given a DOM
    element and an object (a mapping of attribute name to value), update the DOM
    element's attributes.
</p>

<div class="code-container">
  <pre><code key="__reec0eec1c0"><span class="parsed_COMMENT" key="__reec0eec1c0c0">/**
 * Applies a dictionary representation of the HTMLElement properties
 * to the element.
 */</span>
<span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c2">const</span> updateAttrs = (el: TaggedElement, attrs: <span class="parsed_KEYWORD" key="__reec0eec1c0c4">object</span>) =&gt; {
  <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c6">const</span> [, prevAttrs] = el._hic || [];

  Object
    .<span class="parsed_FUNC_CALL" key="__reec0eec1c0c8">entries</span>(attrs)
    .<span class="parsed_FUNC_CALL" key="__reec0eec1c0c10">forEach</span>(([k, v]) =&gt; { 
      <span class="parsed_KEYWORD" key="__reec0eec1c0c12">if</span> (prevAttrs &amp;&amp; <span class="parsed_KEYWORD" key="__reec0eec1c0c14">typeof</span> prevAttrs[k] === <span class="parsed_STRING" key="__reec0eec1c0c16">"function"</span>) {
        el.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c18">removeEventListener</span>(k, prevAttrs[k]);
      }

      <span class="parsed_KEYWORD" key="__reec0eec1c0c20">if</span> (<span class="parsed_KEYWORD" key="__reec0eec1c0c22">typeof</span> v === FUNC_TOKEN) {
        el.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c24">addEventListener</span>(k.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c26">toLowerCase</span>(), v);
      } <span class="parsed_KEYWORD" key="__reec0eec1c0c28">else</span> {
        <span class="parsed_COMMENT" key="__reec0eec1c0c30">// Weird specific case. The view doesn't update if you do el.setAttribute('value', 10) on an input element.</span>
        <span class="parsed_KEYWORD" key="__reec0eec1c0c32">if</span> (k === <span class="parsed_STRING" key="__reec0eec1c0c34">'value'</span> || k === <span class="parsed_STRING" key="__reec0eec1c0c36">'disabled'</span>) {
          el[k] = v;
          <span class="parsed_KEYWORD" key="__reec0eec1c0c38">return</span>;
        }
        
        <span class="parsed_KEYWORD_CONST" key="__reec0eec1c0c40">const</span> asElement = el <span class="parsed_KEYWORD" key="__reec0eec1c0c42">as</span> TaggedElement;
        <span class="parsed_KEYWORD" key="__reec0eec1c0c44">if</span> (asElement.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c46">getAttribute</span>(k) !== v) {
          asElement.<span class="parsed_FUNC_CALL" key="__reec0eec1c0c48">setAttribute</span>(k, v);
        }
      }
    })

  <span class="parsed_KEYWORD" key="__reec0eec1c0c50">return</span> el;
}
   </code></pre>
</div>

TODO Add a thing at the end suggesting to let me know if any issues are spotted
or any obvious reductions are possible

<div id="archetype1_container">
<pre>
<code>
code here.
</code>
</pre>
</div>

<h2>2. Render JSX "components"</h2>

<p>
    Given some JSX, render the JSX and all of its children until reaching "leaf"
    nodes. A leaf node is a real HTML DOM element such as <code>span</code> or
    <code>p</code>, or a text node.
</p>

<div id="archetype2_container">
<pre>
<code>
code here.
</code>
</pre>
</div>


<h2>Whatever</h2>

<p>
Anyway I'm a bit bored writing about all of them, but you get the gist. You can
find the complete code for this approach
<a href="https://github.com/curlywurlycraig/vdom-util">here</a>.
</p>

<p>
Really, I just want to solve the problem I face directly, and this small excursion into general purpose tooling
for making modifications to the DOM in a reactive manner (while keeping bundle
size very small) was satisfactory.
</p>

<p>
    I am still back and forth about whether I want to just focus on the MVP of
    my game, or spend time on my own tooling. I'm fine with my own tooling for now...
</p>

  </body>
</html>